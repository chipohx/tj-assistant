# TEST CASES API

## /api/auth

### /register
#### Формат тела запроса: username=test@gmail.com&password=123123 (это для примера)
#### Заголовок запроса: Content-Type: application/x-www-form-urlencoded
#### Параметры запроса
Форма данных (OAuth2PasswordRequestForm):
- `username` (string, required) - Email пользователя
- `password` (string, required) - Пароль пользователя
1) Позитивный сценарий регистрации - 200 код ответа
#### Пред-условия: Пользователь не зарегестрирован в системе или не активирован
#### Шаги для воспроизведения: 
1. Сгенерировать 10 уникальных тестовых username и password через генератор
2. Ввести в поле запроса username и password по формату тела запроса 
#### Ожидаемый результат: 
Статус код 200 с телом ответа 
{
  "detail": "Account created successfully",
  "email": "youremail@email.com"
}

2) Негативный сценарий регистрации - 409 код ответа
#### Пред-условия: Пользователь зарегестрирован в системе и активирован
#### Шаги для воспроизведения: 
1. Взять username и password из заранее определённого списка зарегестрированных и активированных пользователей из файла .env (список activated_users)
2. Ввести в поле запроса username и password по формату тела запроса из списка activated_users 
#### Ожидаемый результат: 
Статус код 409 с телом ответа 
{
  "detail": "Account already exists"
}

### /login
#### Формат тела запроса: username=test@gmail.com&password=123123 (это для примера)
#### Заголовок запроса: Content-Type: application/x-www-form-urlencoded
#### Параметры запроса
Форма данных (OAuth2PasswordRequestForm):
- `username` (string, required) - Email пользователя
- `password` (string, required) - Пароль пользователя

1) Позитивный сценарий авторизации - 200 код ответа
#### Пред-условия: Пользователь зарегистрирован в системе и активирован
#### Шаги для воспроизведения: 
1. Взять username и password из заранее определённого списка зарегистрированных и активированных пользователей (timonsafren и insledat1on11)
2. Ввести в поле запроса username и password по формату тела запроса
#### Ожидаемый результат: 
Статус код 200 с телом ответа 
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}

2) Негативный сценарий авторизации - 400 код ответа
#### Пред-условия: Пользователь не зарегистрирован в системе или неверные учетные данные
#### Шаги для воспроизведения: 
1. Ввести в поле запроса неверные username и password (например, несуществующий пользователь или неверный пароль)
2. Ввести в поле запроса username и password по формату тела запроса
#### Ожидаемый результат: 
Статус код 400 с телом ответа 
{
  "detail": "Invalid username or password"
}

## /api/users

### /users/me
#### Формат заголовка запроса: Authorization: Bearer <access_token>
#### Параметры запроса
Нет

1) Позитивный сценарий получения информации о пользователе - 200 код ответа
#### Пред-условия: Пользователь зарегистрирован, активирован и имеет валидный токен авторизации
#### Шаги для воспроизведения: 
1. Взять токены авторизации из ACCESS_TOKENS_LOGIN_USERS из .env файла (токены соответствуют почтам из ACTIVATED_USERS_LOGIN по порядку)
2. Отправить GET запрос с заголовком Authorization: Bearer <token>
3. Сравнить возвращенный email с соответствующим email из ACTIVATED_USERS_LOGIN
#### Ожидаемый результат: 
Статус код 200 с телом ответа 
{
  "username": "email@example.com"
}
Email в ответе должен соответствовать email из ACTIVATED_USERS_LOGIN для данного токена

2) Негативный сценарий получения информации о пользователе - 401 код ответа
#### Пред-условия: Используется невалидный или сгенерированный токен
#### Шаги для воспроизведения: 
1. Сгенерировать невалидные токены через генератор
2. Отправить GET запрос с заголовком Authorization: Bearer <невалидный_токен>
#### Ожидаемый результат: 
Статус код 401 с телом ответа 
{
  "detail": "Not authenticated"
}

## /api/chat

### /new-chat

#### Формат заголовка запроса:  
Authorization: Bearer \<access_token\>  
Content-Type: application/json

#### Параметры запроса  
Нет

1) Позитивный сценарий создания нового чата - 200 код ответа  
#### Пред-условия:  
- Пользователь зарегистрирован, активирован и имеет валидный токен авторизации  

#### Шаги для воспроизведения:  
1. Получить валидный `access_token` через уже существующую фикстуру авторизации  
2. Отправить `POST` запрос на `/api/new-chat` с заголовком `Authorization: Bearer <access_token>`  
3. Сохранить `chat_id` из ответа для последующих проверок  

#### Ожидаемый результат:  
Статус код 200 с телом ответа:
```json
{
  "chat_id": "uuid"
}
```
`chat_id` должен быть валидным UUID.

2) Негативный сценарий создания нового чата без авторизации - 401 код ответа  
#### Пред-условия:  
- Токен авторизации не передаётся или является невалидным  

#### Шаги для воспроизведения:  
1. Отправить `POST` запрос на `/api/new-chat` **без** заголовка `Authorization`  
2. (опционально) Отправить запрос с заведомо невалидным токеном `Authorization: Bearer invalid_token`  

#### Ожидаемый результат:  
Статус код 401 с телом ответа:
```json
{
  "detail": "Not authenticated"
}
```

---

### /chat (POST)

#### Формат заголовка запроса:  
Authorization: Bearer \<access_token\>  
Content-Type: application/json

#### Параметры запроса (тело):  
```json
{
  "content": "string",
  "chat_id": "uuid | null"
}
```

1) Позитивный сценарий отправки сообщения в уже существующий чат - 200 код ответа  
#### Пред-условия:  
- Пользователь зарегистрирован, активирован и имеет валидный токен авторизации  
- У пользователя уже есть существующий чат (создан заранее через `/api/new-chat` или фикстуру)  

#### Шаги для воспроизведения:  
1. Получить валидный `access_token` через фикстуру авторизации  
2. Создать новый чат через `/api/new-chat` или получить `chat_id` из фикстуры  
3. Отправить `POST` запрос на `/api/chat` с телом:
```json
{
  "content": "Тестовое сообщение",
  "chat_id": "<существующий_chat_id>"
}
```
4. Убедиться, что запрос прошёл без ошибок и вернул 200  

#### Ожидаемый результат:  
Статус код 200 с телом ответа:
```json
{
  "message_id": "uuid",
  "content": "string",
  "timestamp": "datetime",
  "chat_created": null
}
```
`message_id` и `timestamp` заданы, поле `chat_created` либо отсутствует, либо равно `null` (новый чат не создавался).

2) Позитивный сценарий отправки сообщения без указания chat_id (создание нового чата) - 200 код ответа  
#### Пред-условия:  
- Пользователь зарегистрирован, активирован и имеет валидный токен авторизации  

#### Шаги для воспроизведения:  
1. Получить валидный `access_token` через фикстуру авторизации  
2. Отправить `POST` запрос на `/api/chat` с телом:
```json
{
  "content": "Первое сообщение без chat_id"
}
```
3. Сохранить `chat_created` из ответа как новый `chat_id`  

#### Ожидаемый результат:  
Статус код 200 с телом ответа:
```json
{
  "message_id": "uuid",
  "content": "string",
  "timestamp": "datetime",
  "chat_created": "uuid"
}
```
`chat_created` должен быть валидным UUID, отличным от `null`. В БД должен появиться новый чат, связанный с пользователем.

3) Негативный сценарий отправки сообщения без авторизации - 401 код ответа  
#### Пред-условия:  
- Токен авторизации не передаётся или является невалидным  

#### Шаги для воспроизведения:  
1. Отправить `POST` запрос на `/api/chat` без заголовка `Authorization` с любым телом:
```json
{
  "content": "Сообщение без авторизации"
}
```

#### Ожидаемый результат:  
Статус код 401 с телом ответа:
```json
{
  "detail": "Not authenticated"
}
```

4) Негативный сценарий при недоступности LLM сервиса - 500 код ответа  
#### Пред-условия:  
- Пользователь авторизован (валидный `access_token`)  
- В тесте замокан HTTP-клиент `httpx.AsyncClient` или вызов к `http://main:8001/health` / `http://main:8001/llm_response`, чтобы имитировать сетевую ошибку (raise `httpx.RequestError`)  

#### Шаги для воспроизведения:  
1. Через мок настроить, чтобы любой запрос к LLM (`health` или `llm_response`) выбрасывал `httpx.RequestError`  
2. Отправить `POST` запрос на `/api/chat` с валидным телом и заголовком `Authorization`  

#### Ожидаемый результат:  
Статус код 500 с телом ответа:
```json
{
  "detail": "LLM service unreachable"
}
```

5) Негативный сценарий при неуспешном health check LLM сервиса - 503 код ответа  
#### Пред-условия:  
- Пользователь авторизован  
- В тесте замокан запрос `GET http://main:8001/health`, чтобы он возвращал статус-код, отличный от 200 (например 500)  

#### Шаги для воспроизведения:  
1. Замокать ответ health check так, чтобы он возвращал `status_code != 200`  
2. Отправить `POST` запрос на `/api/chat` с валидным телом и заголовком `Authorization`  

#### Ожидаемый результат:  
Статус код 503 с телом ответа:
```json
{
  "detail": "LLM service health check failed: ..."
}
```

6) Негативные сценарии с некорректным ответом LLM сервиса - 502 код ответа  
#### Пред-условия:  
- Пользователь авторизован  
- В тесте замокан ответ `POST http://main:8001/llm_response`  

#### Вариант A — LLM вернул невалидный JSON:  
1. Замокать вызов LLM так, чтобы `response.text` содержал невалидный JSON и при вызове `response.json()` выбрасывал `ValueError`  
2. Отправить `POST` запрос на `/api/chat`  

Ожидаемый результат: статус код 502 с телом:
```json
{
  "detail": "Invalid JSON from LLM service"
}
```

#### Вариант B — LLM вернул пустой ответ:  
1. Замокать вызов LLM так, чтобы `response.json()` возвращал объект без `response` или с пустой строкой  
2. Отправить `POST` запрос на `/api/chat`  

Ожидаемый результат: статус код 502 с телом:
```json
{
  "detail": "Empty response from LLM service"
}
```

---

### /chats (GET)

#### Формат заголовка запроса:  
Authorization: Bearer \<access_token\>

#### Параметры запроса  
Нет

1) Позитивный сценарий получения списка чатов пользователя - 200 код ответа  
#### Пред-условия:  
- Пользователь зарегистрирован, активирован и имеет валидный токен авторизации  

#### Шаги для воспроизведения:  
1. Получить валидный `access_token` через фикстуру авторизации  
2. Создать несколько чатов для пользователя через `/api/new-chat` (например 2–3 чата)  
3. Отправить `GET` запрос на `/api/chats` с заголовком `Authorization: Bearer <access_token>`  
4. Проверить, что в ответе присутствуют созданные ранее чаты (по `id` и `title`)  
5. В финализаторе удалить созданные тестовые чаты из БД (если требуется явная очистка)  

#### Ожидаемый результат:  
Статус код 200 с телом ответа:
```json
{
  "items": [
    {
      "id": "uuid",
      "title": "Новый чат",
      "created": "datetime"
    }
  ]
}
```
Список `items` не пустой, содержит чаты текущего пользователя.

2) Негативный сценарий получения списка чатов без авторизации - 401 код ответа  
#### Пред-условия:  
- Токен авторизации не передаётся или является невалидным  

#### Шаги для воспроизведения:  
1. Отправить `GET` запрос на `/api/chats` без заголовка `Authorization`  

#### Ожидаемый результат:  
Статус код 401 с телом ответа:
```json
{
  "detail": "Not authenticated"
}
```

---

### /chat/{chat_id}/messages (GET)

#### Формат заголовка запроса:  
Authorization: Bearer \<access_token\>

#### Параметры пути:  
- `chat_id` (uuid, required) — идентификатор чата

#### Параметры запроса (query):  
- `limit` (integer, optional, по умолчанию 20)  
- `last_id` (uuid, optional)

1) Позитивный сценарий получения сообщений чата - 200 код ответа  
#### Пред-условия:  
- Пользователь зарегистрирован, активирован и имеет валидный токен авторизации  

#### Шаги для воспроизведения:  
1. Получить валидный `access_token` через фикстуру авторизации  
2. Создать новый чат через `/api/new-chat` и сохранить `chat_id`  
3. Отправить `POST` запрос на `/api/chat` с телом:
```json
{
  "content": "Сообщение для проверки истории",
  "chat_id": "<созданный_chat_id>"
}
```
4. Отправить `GET` запрос на `/api/chat/{chat_id}/messages` с подстановкой `chat_id` созданного чата и заголовком `Authorization: Bearer <access_token>`  
5. (опционально) Указать `limit=20` и/или `last_id` для проверки пагинации  

#### Ожидаемый результат:  
Статус код 200 с телом ответа:
```json
{
  "count": "integer",
  "next_id": "uuid | null",
  "items": [
    {
      "id": "uuid",
      "content": "string",
      "role": "user | system",
      "created": "datetime"
    }
  ]
}
```
В списке `items` должно присутствовать как минимум одно сообщение с `content`, соответствующим отправленному через `/api/chat`. Поле `role` должно быть `user` или `system`.

2) Негативный сценарий получения сообщений без авторизации - 401 код ответа  
#### Пред-условия:  
- Токен авторизации не передаётся или является невалидным  
- В системе существует хотя бы один чат (можно создать заранее через фикстуру)  

#### Шаги для воспроизведения:  
1. Взять существующий `chat_id` (созданный ранее для теста)  
2. Отправить `GET` запрос на `/api/chat/{chat_id}/messages` без заголовка `Authorization`  

#### Ожидаемый результат:  
Статус код 401 с телом ответа:
```json
{
  "detail": "Not authenticated"
}
```